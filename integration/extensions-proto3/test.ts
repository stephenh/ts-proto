// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: test.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "";

export interface ServiceInfo {
  requiredHeaders: string[];
  maximumMessageSizeBytes: number;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface ResponseInfo {
  expectedErrorCodes: number[];
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface MessageInfo {
  entityTable: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

export interface UnaryRequest {
  message: string;
  _unknownFields?: { [key: number]: Uint8Array[] } | undefined;
}

function createBaseServiceInfo(): ServiceInfo {
  return { requiredHeaders: [], maximumMessageSizeBytes: 0, _unknownFields: {} };
}

export const ServiceInfo: MessageFns<ServiceInfo> = {
  encode(message: ServiceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requiredHeaders) {
      writer.uint32(10).string(v!);
    }
    if (message.maximumMessageSizeBytes !== 0) {
      writer.uint32(16).int32(message.maximumMessageSizeBytes);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag).raw(value);
        }
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requiredHeaders.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maximumMessageSizeBytes = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const buf = reader.skip(tag & 7);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ServiceInfo {
    return {
      requiredHeaders: globalThis.Array.isArray(object?.requiredHeaders)
        ? object.requiredHeaders.map((e: any) => globalThis.String(e))
        : [],
      maximumMessageSizeBytes: isSet(object.maximumMessageSizeBytes)
        ? globalThis.Number(object.maximumMessageSizeBytes)
        : 0,
    };
  },

  toJSON(message: ServiceInfo): unknown {
    const obj: any = {};
    if (message.requiredHeaders?.length) {
      obj.requiredHeaders = message.requiredHeaders;
    }
    if (message.maximumMessageSizeBytes !== 0) {
      obj.maximumMessageSizeBytes = Math.round(message.maximumMessageSizeBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceInfo>, I>>(base?: I): ServiceInfo {
    return ServiceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceInfo>, I>>(object: I): ServiceInfo {
    const message = createBaseServiceInfo();
    message.requiredHeaders = object.requiredHeaders?.map((e) => e) || [];
    message.maximumMessageSizeBytes = object.maximumMessageSizeBytes ?? 0;
    return message;
  },
};

function createBaseResponseInfo(): ResponseInfo {
  return { expectedErrorCodes: [], _unknownFields: {} };
}

export const ResponseInfo: MessageFns<ResponseInfo> = {
  encode(message: ResponseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.expectedErrorCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag).raw(value);
        }
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.expectedErrorCodes.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.expectedErrorCodes.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const buf = reader.skip(tag & 7);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): ResponseInfo {
    return {
      expectedErrorCodes: globalThis.Array.isArray(object?.expectedErrorCodes)
        ? object.expectedErrorCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ResponseInfo): unknown {
    const obj: any = {};
    if (message.expectedErrorCodes?.length) {
      obj.expectedErrorCodes = message.expectedErrorCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseInfo>, I>>(base?: I): ResponseInfo {
    return ResponseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseInfo>, I>>(object: I): ResponseInfo {
    const message = createBaseResponseInfo();
    message.expectedErrorCodes = object.expectedErrorCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMessageInfo(): MessageInfo {
  return { entityTable: "", _unknownFields: {} };
}

export const MessageInfo: MessageFns<MessageInfo> = {
  encode(message: MessageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityTable !== "") {
      writer.uint32(10).string(message.entityTable);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag).raw(value);
        }
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityTable = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const buf = reader.skip(tag & 7);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): MessageInfo {
    return { entityTable: isSet(object.entityTable) ? globalThis.String(object.entityTable) : "" };
  },

  toJSON(message: MessageInfo): unknown {
    const obj: any = {};
    if (message.entityTable !== "") {
      obj.entityTable = message.entityTable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageInfo>, I>>(base?: I): MessageInfo {
    return MessageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageInfo>, I>>(object: I): MessageInfo {
    const message = createBaseMessageInfo();
    message.entityTable = object.entityTable ?? "";
    return message;
  },
};

function createBaseUnaryRequest(): UnaryRequest {
  return { message: "", _unknownFields: {} };
}

export const UnaryRequest: MessageFns<UnaryRequest> = {
  encode(message: UnaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message._unknownFields !== undefined) {
      for (const [key, values] of Object.entries(message._unknownFields)) {
        const tag = parseInt(key, 10);
        for (const value of values) {
          writer.uint32(tag).raw(value);
        }
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      const buf = reader.skip(tag & 7);

      const list = message._unknownFields![tag];

      if (list === undefined) {
        message._unknownFields![tag] = [buf];
      } else {
        list.push(buf);
      }
    }
    return message;
  },

  fromJSON(object: any): UnaryRequest {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: UnaryRequest): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnaryRequest>, I>>(base?: I): UnaryRequest {
    return UnaryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnaryRequest>, I>>(object: I): UnaryRequest {
    const message = createBaseUnaryRequest();
    message.message = object.message ?? "";
    return message;
  },
};

export const serviceInfo: Extension<ServiceInfo | undefined> = {
  number: 1001,
  tag: 8010,
  repeated: false,
  packed: false,
  encode: (value: ServiceInfo | undefined): Uint8Array[] => {
    const encoded: Uint8Array[] = [];
    const writer = new BinaryWriter();
    ServiceInfo.encode(value, writer.fork()).join();
    encoded.push(writer.finish());
    return encoded;
  },
  decode: (tag: number, input: Uint8Array[]): ServiceInfo | undefined => {
    const reader = new BinaryReader(input[input.length - 1] ?? fail());
    return ServiceInfo.decode(reader, reader.uint32());
  },
};

export const responseInfo: Extension<ResponseInfo | undefined> = {
  number: 1002,
  tag: 8018,
  repeated: false,
  packed: false,
  encode: (value: ResponseInfo | undefined): Uint8Array[] => {
    const encoded: Uint8Array[] = [];
    const writer = new BinaryWriter();
    ResponseInfo.encode(value, writer.fork()).join();
    encoded.push(writer.finish());
    return encoded;
  },
  decode: (tag: number, input: Uint8Array[]): ResponseInfo | undefined => {
    const reader = new BinaryReader(input[input.length - 1] ?? fail());
    return ResponseInfo.decode(reader, reader.uint32());
  },
};

export const messageInfo: Extension<MessageInfo | undefined> = {
  number: 1003,
  tag: 8026,
  repeated: false,
  packed: false,
  encode: (value: MessageInfo | undefined): Uint8Array[] => {
    const encoded: Uint8Array[] = [];
    const writer = new BinaryWriter();
    MessageInfo.encode(value, writer.fork()).join();
    encoded.push(writer.finish());
    return encoded;
  },
  decode: (tag: number, input: Uint8Array[]): MessageInfo | undefined => {
    const reader = new BinaryReader(input[input.length - 1] ?? fail());
    return MessageInfo.decode(reader, reader.uint32());
  },
};

export const maxLength: Extension<number> = {
  number: 1004,
  tag: 8032,
  repeated: false,
  packed: false,
  encode: (value: number): Uint8Array[] => {
    const encoded: Uint8Array[] = [];
    if (value !== 0) {
      const writer = new BinaryWriter();
      writer.int32(value);
      encoded.push(writer.finish());
    }
    return encoded;
  },
  decode: (tag: number, input: Uint8Array[]): number => {
    const reader = new BinaryReader(input[input.length - 1] ?? fail());
    return reader.int32();
  },
};

export interface ExtensionService {
  Unary(request: UnaryRequest): Promise<Empty>;
}

export const ExtensionServiceServiceName = "ExtensionService";
export class ExtensionServiceClientImpl implements ExtensionService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ExtensionServiceServiceName;
    this.rpc = rpc;
    this.Unary = this.Unary.bind(this);
  }
  Unary(request: UnaryRequest): Promise<Empty> {
    const data = UnaryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Unary", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }
}

export type ExtensionServiceDefinition = typeof ExtensionServiceDefinition;
export const ExtensionServiceDefinition = {
  name: "ExtensionService",
  fullName: "ExtensionService",
  methods: {
    unary: {
      name: "Unary",
      requestType: UnaryRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: { _unknownFields: { 8018: [new Uint8Array([4, 10, 2, 101, 102])] } },
    },
  },
} as const;

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface Extension<T> {
  number: number;
  tag: number;
  singularTag?: number;
  encode?: (message: T) => Uint8Array[];
  decode?: (tag: number, input: Uint8Array[]) => T;
  repeated: boolean;
  packed: boolean;
}

function fail(message?: string): never {
  throw new globalThis.Error(message ?? "Failed");
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
