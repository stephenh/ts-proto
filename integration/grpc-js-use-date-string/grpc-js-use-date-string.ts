// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: grpc-js-use-date-string.proto

    /* eslint-disable */
import { makeGenericClientConstructor, ChannelCredentials, Client, Metadata } from '@grpc/grpc-js';
import type { ClientOptions, UntypedServiceImplementation, handleUnaryCall, ClientUnaryCall, CallOptions, ServiceError } from '@grpc/grpc-js';
import { BinaryWriter, BinaryReader } from '@bufbuild/protobuf/wire';
import { Timestamp } from './google/protobuf/timestamp';

export const protobufPackage = 'simple';

export interface TimestampMessage {
timestamp: string | undefined,
}

function createBaseTimestampMessage(): TimestampMessage {
      return { timestamp: undefined };
    }

export const TimestampMessage: MessageFns<TimestampMessage> = {
              encode(
      message: TimestampMessage,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
if (message.timestamp !== undefined ) {
          Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
        }
return writer;
},

decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TimestampMessage {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
const message = createBaseTimestampMessage();
while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
case 1: {
if (tag !== 10) {
        break;
      }
    
        message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
continue; }
}
if ((tag & 7) === 4 || tag === 0) {
        break;
      }
reader.skip(tag & 7);
}
return message;
},

fromJSON(object: any): TimestampMessage {
      return {
timestamp: isSet(object.timestamp)
          ? globalThis.String(object.timestamp)
          : undefined,
};
},

toJSON(message: TimestampMessage): unknown {
      const obj: any = {};
if (message.timestamp !== undefined ) {
          obj.timestamp = message.timestamp;
        }
return obj;
},

create<I extends Exact<DeepPartial<TimestampMessage>, I>>(base?: I): TimestampMessage {
        return TimestampMessage.fromPartial(base ?? ({} as any));
      },
fromPartial<I extends Exact<DeepPartial<TimestampMessage>, I>>(object: I): TimestampMessage {
const message = createBaseTimestampMessage();
message.timestamp = object.timestamp ?? undefined;
return message;
}
            };

export type TestService = typeof TestService;
export const TestService = {
simpleNow: {
        path: '/simple.Test/SimpleNow',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: string) =>
          Buffer.from(Timestamp.encode(toTimestamp(value)).finish()),
        requestDeserialize: (value: Buffer) => fromTimestamp(Timestamp.decode(value)),
        responseSerialize: (value: string) =>
          Buffer.from(Timestamp.encode(toTimestamp(value)).finish()),
        responseDeserialize: (value: Buffer) => fromTimestamp(Timestamp.decode(value)),
      },
wrappedNow: {
        path: '/simple.Test/WrappedNow',
        requestStream: false,
        responseStream: false,
        requestSerialize: (value: TimestampMessage) =>
          Buffer.from(TimestampMessage.encode(value).finish()),
        requestDeserialize: (value: Buffer) => TimestampMessage.decode(value),
        responseSerialize: (value: TimestampMessage) =>
          Buffer.from(TimestampMessage.encode(value).finish()),
        responseDeserialize: (value: Buffer) => TimestampMessage.decode(value),
      },
} as const;

export interface TestServer extends UntypedServiceImplementation {
simpleNow: handleUnaryCall<string, string>;
wrappedNow: handleUnaryCall<TimestampMessage, TimestampMessage>;
}

export interface TestClient extends Client {
simpleNow(
            request: string,
            callback: (error: ServiceError | null, response: string) => void,
          ): ClientUnaryCall;
          simpleNow(
            request: string,
            metadata: Metadata,
            callback: (error: ServiceError | null, response: string) => void,
          ): ClientUnaryCall;
          simpleNow(
            request: string,
            metadata: Metadata,
            options: Partial<CallOptions>,
            callback: (error: ServiceError | null, response: string) => void,
          ): ClientUnaryCall;
wrappedNow(
            request: TimestampMessage,
            callback: (error: ServiceError | null, response: TimestampMessage) => void,
          ): ClientUnaryCall;
          wrappedNow(
            request: TimestampMessage,
            metadata: Metadata,
            callback: (error: ServiceError | null, response: TimestampMessage) => void,
          ): ClientUnaryCall;
          wrappedNow(
            request: TimestampMessage,
            metadata: Metadata,
            options: Partial<CallOptions>,
            callback: (error: ServiceError | null, response: TimestampMessage) => void,
          ): ClientUnaryCall;
}

export const TestClient = makeGenericClientConstructor(
      TestService,
      'simple.Test'
    ) as unknown as {
      new (
        address: string,
        credentials: ChannelCredentials,
        options?: Partial<ClientOptions>,
      ): TestClient;
      service: typeof TestService;
      serviceName: string;
    }







type Builtin = Date | Function | Uint8Array | string | number | boolean |  | undefined;

export type DeepPartial<T> =  T extends Builtin
        ? T
        
        : T extends globalThis.Array<infer U>
        ? globalThis.Array<DeepPartial<U>>
        : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
      export type Exact<P, I extends P> = P extends Builtin
        ? P
        : P &
        { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> >]: never };







function toTimestamp(dateStr: string): Timestamp {
            const date = new globalThis.Date(dateStr);
            const seconds = Math.trunc(date.getTime() / 1_000);
            const nanos = (date.getTime() % 1_000) * 1_000_000;
            return {  seconds, nanos };
          }

function fromTimestamp(t: Timestamp): string {
            let millis = (t.seconds || 0) * 1_000;
            millis += (t.nanos || 0) / 1_000_000;
            return new globalThis.Date(millis).toISOString();
          }











function isSet(value: any): boolean {
      return value !== null && value !== undefined;
    }









export interface MessageFns<T> {
        encode(message: T, writer?: BinaryWriter): BinaryWriter;
decode(input: BinaryReader | Uint8Array, length?: number): T;
fromJSON(object: any): T;
toJSON(message: T): unknown;
create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
      }











