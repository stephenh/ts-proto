// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v3.21.12
// source: a2a.proto

/* eslint-disable */
import { Timestamp } from "./google/protobuf/timestamp.js";

export const protobufPackage = "a2a.v1";

/** Older protoc compilers don't understand edition yet. */

/** The set of states a Task can be in. */
export enum TaskState {
  TASK_STATE_UNSPECIFIED = 0,
  /** TASK_STATE_SUBMITTED - Represents the status that acknowledges a task is created */
  TASK_STATE_SUBMITTED = 1,
  /** TASK_STATE_WORKING - Represents the status that a task is actively being processed */
  TASK_STATE_WORKING = 2,
  /** TASK_STATE_COMPLETED - Represents the status a task is finished. This is a terminal state */
  TASK_STATE_COMPLETED = 3,
  /** TASK_STATE_FAILED - Represents the status a task is done but failed. This is a terminal state */
  TASK_STATE_FAILED = 4,
  /**
   * TASK_STATE_CANCELLED - Represents the status a task was cancelled before it finished.
   * This is a terminal state.
   */
  TASK_STATE_CANCELLED = 5,
  /**
   * TASK_STATE_INPUT_REQUIRED - Represents the status that the task requires information to complete.
   * This is an interrupted state.
   */
  TASK_STATE_INPUT_REQUIRED = 6,
  /**
   * TASK_STATE_REJECTED - Represents the status that the agent has decided to not perform the task.
   * This may be done during initial task creation or later once an agent
   * has determined it can't or won't proceed. This is a terminal state.
   */
  TASK_STATE_REJECTED = 7,
  /**
   * TASK_STATE_AUTH_REQUIRED - Represents the state that some authentication is needed from the upstream
   * client. Authentication is expected to come out-of-band thus this is not
   * an interrupted or terminal state.
   */
  TASK_STATE_AUTH_REQUIRED = 8,
  UNRECOGNIZED = -1,
}

export function taskStateFromJSON(object: any): TaskState {
  switch (object) {
    case 0:
    case "TASK_STATE_UNSPECIFIED":
      return TaskState.TASK_STATE_UNSPECIFIED;
    case 1:
    case "TASK_STATE_SUBMITTED":
      return TaskState.TASK_STATE_SUBMITTED;
    case 2:
    case "TASK_STATE_WORKING":
      return TaskState.TASK_STATE_WORKING;
    case 3:
    case "TASK_STATE_COMPLETED":
      return TaskState.TASK_STATE_COMPLETED;
    case 4:
    case "TASK_STATE_FAILED":
      return TaskState.TASK_STATE_FAILED;
    case 5:
    case "TASK_STATE_CANCELLED":
      return TaskState.TASK_STATE_CANCELLED;
    case 6:
    case "TASK_STATE_INPUT_REQUIRED":
      return TaskState.TASK_STATE_INPUT_REQUIRED;
    case 7:
    case "TASK_STATE_REJECTED":
      return TaskState.TASK_STATE_REJECTED;
    case 8:
    case "TASK_STATE_AUTH_REQUIRED":
      return TaskState.TASK_STATE_AUTH_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskState.UNRECOGNIZED;
  }
}

export function taskStateToJSON(object: TaskState): string {
  switch (object) {
    case TaskState.TASK_STATE_UNSPECIFIED:
      return "TASK_STATE_UNSPECIFIED";
    case TaskState.TASK_STATE_SUBMITTED:
      return "TASK_STATE_SUBMITTED";
    case TaskState.TASK_STATE_WORKING:
      return "TASK_STATE_WORKING";
    case TaskState.TASK_STATE_COMPLETED:
      return "TASK_STATE_COMPLETED";
    case TaskState.TASK_STATE_FAILED:
      return "TASK_STATE_FAILED";
    case TaskState.TASK_STATE_CANCELLED:
      return "TASK_STATE_CANCELLED";
    case TaskState.TASK_STATE_INPUT_REQUIRED:
      return "TASK_STATE_INPUT_REQUIRED";
    case TaskState.TASK_STATE_REJECTED:
      return "TASK_STATE_REJECTED";
    case TaskState.TASK_STATE_AUTH_REQUIRED:
      return "TASK_STATE_AUTH_REQUIRED";
    case TaskState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Role {
  ROLE_UNSPECIFIED = 0,
  /** ROLE_USER - USER role refers to communication from the client to the server. */
  ROLE_USER = 1,
  /** ROLE_AGENT - AGENT role refers to communication from the server to the client. */
  ROLE_AGENT = 2,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return Role.ROLE_UNSPECIFIED;
    case 1:
    case "ROLE_USER":
      return Role.ROLE_USER;
    case 2:
    case "ROLE_AGENT":
      return Role.ROLE_AGENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case Role.ROLE_USER:
      return "ROLE_USER";
    case Role.ROLE_AGENT:
      return "ROLE_AGENT";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration of a send message request. */
export interface SendMessageConfiguration {
  /** The output modes that the agent is expected to respond with. */
  acceptedOutputModes: string[];
  /** A configuration of a webhook that can be used to receive updates */
  pushNotification:
    | PushNotificationConfig
    | undefined;
  /**
   * The maximum number of messages to include in the history. if 0, the
   * history will be unlimited.
   */
  historyLength: number;
  /**
   * If true, the message will be blocking until the task is completed. If
   * false, the message will be non-blocking and the task will be returned
   * immediately. It is the caller's responsibility to check for any task
   * updates.
   */
  blocking: boolean;
}

/**
 * Task is the core unit of action for A2A. It has a current status
 * and when results are created for the task they are stored in the
 * artifact. If there are multiple turns for a task, these are stored in
 * history.
 */
export interface Task {
  /** Unique identifier for a task, created by the A2A server. */
  id: string;
  /**
   * Unique identifier for the contextual collection of interactions (tasks
   * and messages). Created by the A2A server.
   */
  contextId: string;
  /** The current status of a Task, including state and a message. */
  status:
    | TaskStatus
    | undefined;
  /** A set of output artifacts for a Task. */
  artifacts: Artifact[];
  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * The history of interactions from a task.
   */
  history: Message[];
  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * A key/value object to store custom metadata about a task.
   */
  metadata: { [key: string]: any } | undefined;
}

/** A container for the status of a task */
export interface TaskStatus {
  /** The current state of this task */
  state: TaskState;
  /** A message associated with the status. */
  update:
    | Message
    | undefined;
  /**
   * Timestamp when the status was recorded.
   * Example: "2023-10-27T10:00:00Z"
   */
  timestamp: Date | undefined;
}

/**
 * Part represents a container for a section of communication content.
 * Parts can be purely textual, some sort of file (image, video, etc) or
 * a structured data blob (i.e. JSON).
 */
export interface Part {
  part?:
    | { $case: "text"; value: string }
    | { $case: "file"; value: FilePart }
    | { $case: "data"; value: DataPart }
    | undefined;
}

/**
 * FilePart represents the different ways files can be provided. If files are
 * small, directly feeding the bytes is supported via file_with_bytes. If the
 * file is large, the agent should read the content as appropriate directly
 * from the file_with_uri source.
 */
export interface FilePart {
  file?: { $case: "fileWithUri"; value: string } | { $case: "fileWithBytes"; value: Buffer } | undefined;
  mimeType: string;
}

/** DataPart represents a structured blob. This is most commonly a JSON payload. */
export interface DataPart {
  data: { [key: string]: any } | undefined;
}

/**
 * Message is one unit of communication between client and server. It is
 * associated with a context and optionally a task. Since the server is
 * responsible for the context definition, it must always provide a context_id
 * in its messages. The client can optionally provide the context_id if it
 * knows the context to associate the message to. Similarly for task_id,
 * except the server decides if a task is created and whether to include the
 * task_id.
 */
export interface Message {
  /**
   * The message id of the message. This is required and created by the
   * message creator.
   */
  messageId: string;
  /**
   * The context id of the message. This is optional and if set, the message
   * will be associated with the given context.
   */
  contextId: string;
  /**
   * The task id of the message. This is optional and if set, the message
   * will be associated with the given task.
   */
  taskId: string;
  /** A role for the message. */
  role: Role;
  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Content is the container of the message content.
   */
  content: Part[];
  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * Any optional metadata to provide along with the message.
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** The URIs of extensions that are present or contributed to this Message. */
  extensions: string[];
}

/**
 * Artifacts are the container for task completed results. These are similar
 * to Messages but are intended to be the product of a task, as opposed to
 * point-to-point communication.
 */
export interface Artifact {
  /** Unique id for the artifact. It must be at least unique within a task. */
  artifactId: string;
  /** A human readable name for the artifact. */
  name: string;
  /** A human readable description of the artifact, optional. */
  description: string;
  /** The content of the artifact. */
  parts: Part[];
  /** Optional metadata included with the artifact. */
  metadata:
    | { [key: string]: any }
    | undefined;
  /** The URIs of extensions that are present or contributed to this Artifact. */
  extensions: string[];
}

/**
 * TaskStatusUpdateEvent is a delta even on a task indicating that a task
 * has changed.
 */
export interface TaskStatusUpdateEvent {
  /** The id of the task that is changed */
  taskId: string;
  /** The id of the context that the task belongs to */
  contextId: string;
  /** The new status of the task. */
  status:
    | TaskStatus
    | undefined;
  /** Whether this is the last status update expected for this task. */
  final: boolean;
  /** Optional metadata to associate with the task update. */
  metadata: { [key: string]: any } | undefined;
}

/**
 * TaskArtifactUpdateEvent represents a task delta where an artifact has
 * been generated.
 */
export interface TaskArtifactUpdateEvent {
  /** The id of the task for this artifact */
  taskId: string;
  /** The id of the context that this task belongs too */
  contextId: string;
  /** The artifact itself */
  artifact:
    | Artifact
    | undefined;
  /** Whether this should be appended to a prior one produced */
  append: boolean;
  /** Whether this represents the last part of an artifact */
  lastChunk: boolean;
  /** Optional metadata associated with the artifact update. */
  metadata: { [key: string]: any } | undefined;
}

/** Configuration for setting up push notifications for task updates. */
export interface PushNotificationConfig {
  /** A unique id for this push notification. */
  id: string;
  /** Url to send the notification too */
  url: string;
  /** Token unique for this task/session */
  token: string;
  /** Information about the authentication to sent with the notification */
  authentication: AuthenticationInfo | undefined;
}

/** Defines authentication details, used for push notifications. */
export interface AuthenticationInfo {
  /** Supported authentication schemes - e.g. Basic, Bearer, etc */
  schemes: string[];
  /** Optional credentials */
  credentials: string;
}

/** Defines additional transport information for the agent. */
export interface AgentInterface {
  /** The url this interface is found at. */
  url: string;
  /**
   * The transport supported this url. This is an open form string, to be
   * easily extended for many transport protocols. The core ones officially
   * supported are JSONRPC, GRPC and HTTP+JSON.
   */
  transport: string;
}

/**
 * AgentCard conveys key information:
 * - Overall details (version, name, description, uses)
 * - Skills; a set of actions/solutions the agent can perform
 * - Default modalities/content types supported by the agent.
 * - Authentication requirements
 * Next ID: 18
 */
export interface AgentCard {
  /** The version of the A2A protocol this agent supports. */
  protocolVersion: string;
  /**
   * A human readable name for the agent.
   * Example: "Recipe Agent"
   */
  name: string;
  /**
   * A description of the agent's domain of action/solution space.
   * Example: "Agent that helps users with recipes and cooking."
   */
  description: string;
  /**
   * A URL to the address the agent is hosted at. This represents the
   * preferred endpoint as declared by the agent.
   */
  url: string;
  /** The transport of the preferred endpoint. If empty, defaults to JSONRPC. */
  preferredTransport: string;
  /**
   * Announcement of additional supported transports. Client can use any of
   * the supported transports.
   */
  additionalInterfaces: AgentInterface[];
  /** The service provider of the agent. */
  provider:
    | AgentProvider
    | undefined;
  /**
   * The version of the agent.
   * Example: "1.0.0"
   */
  version: string;
  /** A url to provide additional documentation about the agent. */
  documentationUrl: string;
  /** A2A Capability set supported by the agent. */
  capabilities:
    | AgentCapabilities
    | undefined;
  /** The security scheme details used for authenticating with this agent. */
  securitySchemes: { [key: string]: SecurityScheme };
  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Security requirements for contacting the agent.
   * This list can be seen as an OR of ANDs. Each object in the list describes
   * one possible set of security requirements that must be present on a
   * request. This allows specifying, for example, "callers must either use
   * OAuth OR an API Key AND mTLS."
   * Example:
   * security {
   *   schemes { key: "oauth" value { list: ["read"] } }
   * }
   * security {
   *   schemes { key: "api-key" }
   *   schemes { key: "mtls" }
   * }
   */
  security: Security[];
  /**
   * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
   * The set of interaction modes that the agent supports across all skills.
   * This can be overridden per skill. Defined as mime types.
   */
  defaultInputModes: string[];
  /** The mime types supported as outputs from this agent. */
  defaultOutputModes: string[];
  /**
   * Skills represent a unit of ability an agent can perform. This may
   * somewhat abstract but represents a more focused set of actions that the
   * agent is highly likely to succeed at.
   */
  skills: AgentSkill[];
  /**
   * Whether the agent supports providing an extended agent card when
   * the user is authenticated, i.e. is the card from .well-known
   * different than the card from GetAgentCard.
   */
  supportsAuthenticatedExtendedCard: boolean;
  /** JSON Web Signatures computed for this AgentCard. */
  signatures: AgentCardSignature[];
}

export interface AgentCard_SecuritySchemesEntry {
  key: string;
  value: SecurityScheme | undefined;
}

/** Represents information about the service provider of an agent. */
export interface AgentProvider {
  /**
   * The providers reference url
   * Example: "https://ai.google.dev"
   */
  url: string;
  /**
   * The providers organization name
   * Example: "Google"
   */
  organization: string;
}

/** Defines the A2A feature set supported by the agent */
export interface AgentCapabilities {
  /** If the agent will support streaming responses */
  streaming: boolean;
  /** If the agent can send push notifications to the clients webhook */
  pushNotifications: boolean;
  /** Extensions supported by this agent. */
  extensions: AgentExtension[];
}

/** A declaration of an extension supported by an Agent. */
export interface AgentExtension {
  /**
   * The URI of the extension.
   * Example: "https://developers.google.com/identity/protocols/oauth2"
   */
  uri: string;
  /**
   * A description of how this agent uses this extension.
   * Example: "Google OAuth 2.0 authentication"
   */
  description: string;
  /**
   * Whether the client must follow specific requirements of the extension.
   * Example: false
   */
  required: boolean;
  /** Optional configuration for the extension. */
  params: { [key: string]: any } | undefined;
}

/**
 * AgentSkill represents a unit of action/solution that the agent can perform.
 * One can think of this as a type of highly reliable solution that an agent
 * can be tasked to provide. Agents have the autonomy to choose how and when
 * to use specific skills, but clients should have confidence that if the
 * skill is defined that unit of action can be reliably performed.
 */
export interface AgentSkill {
  /** Unique id of the skill within this agent. */
  id: string;
  /** A human readable name for the skill. */
  name: string;
  /**
   * A human (or llm) readable description of the skill
   * details and behaviors.
   */
  description: string;
  /**
   * A set of tags for the skill to enhance categorization/utilization.
   * Example: ["cooking", "customer support", "billing"]
   */
  tags: string[];
  /**
   * A set of example queries that this skill is designed to address.
   * These examples should help the caller to understand how to craft requests
   * to the agent to achieve specific goals.
   * Example: ["I need a recipe for bread"]
   */
  examples: string[];
  /** Possible input modalities supported. */
  inputModes: string[];
  /** Possible output modalities produced */
  outputModes: string[];
  /**
   * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
   * Security schemes necessary for the agent to leverage this skill.
   * As in the overall AgentCard.security, this list represents a logical OR of
   * security requirement objects. Each object is a set of security schemes
   * that must be used together (a logical AND).
   */
  security: Security[];
}

/**
 * AgentCardSignature represents a JWS signature of an AgentCard.
 * This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
 */
export interface AgentCardSignature {
  /**
   * The protected JWS header for the signature. This is always a
   * base64url-encoded JSON object. Required.
   */
  protected: string;
  /** The computed signature, base64url-encoded. Required. */
  signature: string;
  /** The unprotected JWS header values. */
  header: { [key: string]: any } | undefined;
}

export interface TaskPushNotificationConfig {
  /** name=tasks/{id}/pushNotificationConfigs/{id} */
  name: string;
  pushNotificationConfig: PushNotificationConfig | undefined;
}

/** protolint:disable REPEATED_FIELD_NAMES_PLURALIZED */
export interface StringList {
  list: string[];
}

export interface Security {
  schemes: { [key: string]: StringList };
}

export interface Security_SchemesEntry {
  key: string;
  value: StringList | undefined;
}

export interface SecurityScheme {
  scheme?:
    | { $case: "apiKeySecurityScheme"; value: APIKeySecurityScheme }
    | { $case: "httpAuthSecurityScheme"; value: HTTPAuthSecurityScheme }
    | { $case: "oauth2SecurityScheme"; value: OAuth2SecurityScheme }
    | { $case: "openIdConnectSecurityScheme"; value: OpenIdConnectSecurityScheme }
    | { $case: "mtlsSecurityScheme"; value: MutualTlsSecurityScheme }
    | undefined;
}

export interface APIKeySecurityScheme {
  /** Description of this security scheme. */
  description: string;
  /** Location of the API key, valid values are "query", "header", or "cookie" */
  location: string;
  /** Name of the header, query or cookie parameter to be used. */
  name: string;
}

export interface HTTPAuthSecurityScheme {
  /** Description of this security scheme. */
  description: string;
  /**
   * The name of the HTTP Authentication scheme to be used in the
   * Authorization header as defined in RFC7235. The values used SHOULD be
   * registered in the IANA Authentication Scheme registry.
   * The value is case-insensitive, as defined in RFC7235.
   */
  scheme: string;
  /**
   * A hint to the client to identify how the bearer token is formatted.
   * Bearer tokens are usually generated by an authorization server, so
   * this information is primarily for documentation purposes.
   */
  bearerFormat: string;
}

export interface OAuth2SecurityScheme {
  /** Description of this security scheme. */
  description: string;
  /** An object containing configuration information for the flow types supported */
  flows:
    | OAuthFlows
    | undefined;
  /**
   * URL to the oauth2 authorization server metadata
   * [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
   */
  oauth2MetadataUrl: string;
}

export interface OpenIdConnectSecurityScheme {
  /** Description of this security scheme. */
  description: string;
  /**
   * Well-known URL to discover the [[OpenID-Connect-Discovery]] provider
   * metadata.
   */
  openIdConnectUrl: string;
}

export interface MutualTlsSecurityScheme {
  /** Description of this security scheme. */
  description: string;
}

export interface OAuthFlows {
  flow?:
    | { $case: "authorizationCode"; value: AuthorizationCodeOAuthFlow }
    | { $case: "clientCredentials"; value: ClientCredentialsOAuthFlow }
    | { $case: "implicit"; value: ImplicitOAuthFlow }
    | { $case: "password"; value: PasswordOAuthFlow }
    | undefined;
}

export interface AuthorizationCodeOAuthFlow {
  /**
   * The authorization URL to be used for this flow. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS
   */
  authorizationUrl: string;
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   */
  refreshUrl: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   */
  scopes: { [key: string]: string };
}

export interface AuthorizationCodeOAuthFlow_ScopesEntry {
  key: string;
  value: string;
}

export interface ClientCredentialsOAuthFlow {
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   */
  refreshUrl: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   */
  scopes: { [key: string]: string };
}

export interface ClientCredentialsOAuthFlow_ScopesEntry {
  key: string;
  value: string;
}

export interface ImplicitOAuthFlow {
  /**
   * The authorization URL to be used for this flow. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS
   */
  authorizationUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   */
  refreshUrl: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   */
  scopes: { [key: string]: string };
}

export interface ImplicitOAuthFlow_ScopesEntry {
  key: string;
  value: string;
}

export interface PasswordOAuthFlow {
  /**
   * The token URL to be used for this flow. This MUST be in the form of a URL.
   * The OAuth2 standard requires the use of TLS.
   */
  tokenUrl: string;
  /**
   * The URL to be used for obtaining refresh tokens. This MUST be in the
   * form of a URL. The OAuth2 standard requires the use of TLS.
   */
  refreshUrl: string;
  /**
   * The available scopes for the OAuth2 security scheme. A map between the
   * scope name and a short description for it. The map MAY be empty.
   */
  scopes: { [key: string]: string };
}

export interface PasswordOAuthFlow_ScopesEntry {
  key: string;
  value: string;
}

/** /////////// Request Messages /////////// */
export interface SendMessageRequest {
  request: Message | undefined;
  configuration: SendMessageConfiguration | undefined;
  metadata: { [key: string]: any } | undefined;
}

export interface GetTaskRequest {
  /** name=tasks/{id} */
  name: string;
  historyLength: number;
}

export interface CancelTaskRequest {
  /** name=tasks/{id} */
  name: string;
}

export interface GetTaskPushNotificationConfigRequest {
  /** name=tasks/{id}/pushNotificationConfigs/{push_id} */
  name: string;
}

export interface DeleteTaskPushNotificationConfigRequest {
  /** name=tasks/{id}/pushNotificationConfigs/{push_id} */
  name: string;
}

export interface CreateTaskPushNotificationConfigRequest {
  /**
   * The task resource for this config.
   * Format: tasks/{id}
   */
  parent: string;
  configId: string;
  config: TaskPushNotificationConfig | undefined;
}

export interface TaskSubscriptionRequest {
  /** name=tasks/{id} */
  name: string;
}

export interface ListTaskPushNotificationConfigRequest {
  /** parent=tasks/{id} */
  parent: string;
  /**
   * For AIP-158 these fields are present. Usually not used/needed.
   * The maximum number of configurations to return.
   * If unspecified, all configs will be returned.
   */
  pageSize: number;
  /**
   * A page token received from a previous
   * ListTaskPushNotificationConfigRequest call.
   * Provide this to retrieve the subsequent page.
   * When paginating, all other parameters provided to
   * `ListTaskPushNotificationConfigRequest` must match the call that provided
   * the page token.
   */
  pageToken: string;
}

/** Empty. Added to fix linter violation. */
export interface GetAgentCardRequest {
}

/** ////// Response Messages /////////// */
export interface SendMessageResponse {
  payload?: { $case: "task"; value: Task } | { $case: "msg"; value: Message } | undefined;
}

/**
 * The stream response for a message. The stream should be one of the following
 * sequences:
 * If the response is a message, the stream should contain one, and only one,
 * message and then close
 * If the response is a task lifecycle, the first response should be a Task
 * object followed by zero or more TaskStatusUpdateEvents and
 * TaskArtifactUpdateEvents. The stream should complete when the Task
 * if in an interrupted or terminal state. A stream that ends before these
 * conditions are met are
 */
export interface StreamResponse {
  payload?:
    | { $case: "task"; value: Task }
    | { $case: "msg"; value: Message }
    | { $case: "statusUpdate"; value: TaskStatusUpdateEvent }
    | { $case: "artifactUpdate"; value: TaskArtifactUpdateEvent }
    | undefined;
}

export interface ListTaskPushNotificationConfigResponse {
  configs: TaskPushNotificationConfig[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

export const SendMessageConfiguration: MessageFns<SendMessageConfiguration> = {
  fromJSON(object: any): SendMessageConfiguration {
    return {
      acceptedOutputModes: globalThis.Array.isArray(object?.accepted_output_modes)
        ? object.accepted_output_modes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.acceptedOutputModes)
        ? object.acceptedOutputModes.map((e: any) =>
          globalThis.String(e)
        )
        : [],
      pushNotification: isSet(object.push_notification)
        ? PushNotificationConfig.fromJSON(object.push_notification)
        : isSet(object.pushNotification)
        ? PushNotificationConfig.fromJSON(object.pushNotification)
        : undefined,
      historyLength: isSet(object.history_length)
        ? globalThis.Number(object.history_length)
        : isSet(object.historyLength)
        ? globalThis.Number(object.historyLength)
        : 0,
      blocking: isSet(object.blocking) ? globalThis.Boolean(object.blocking) : false,
    };
  },

  toJSON(message: SendMessageConfiguration): unknown {
    const obj: any = {};
    if (message.acceptedOutputModes?.length) {
      obj.accepted_output_modes = message.acceptedOutputModes;
    }
    if (message.pushNotification !== undefined) {
      obj.push_notification = PushNotificationConfig.toJSON(message.pushNotification);
    }
    if (message.historyLength !== 0) {
      obj.history_length = Math.round(message.historyLength);
    }
    if (message.blocking !== false) {
      obj.blocking = message.blocking;
    }
    return obj;
  },
};

export const Task: MessageFns<Task> = {
  fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contextId: isSet(object.context_id)
        ? globalThis.String(object.context_id)
        : isSet(object.contextId)
        ? globalThis.String(object.contextId)
        : "",
      status: isSet(object.status) ? TaskStatus.fromJSON(object.status) : undefined,
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => Artifact.fromJSON(e))
        : [],
      history: globalThis.Array.isArray(object?.history)
        ? object.history.map((e: any) => Message.fromJSON(e))
        : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contextId !== "") {
      obj.context_id = message.contextId;
    }
    if (message.status !== undefined) {
      obj.status = TaskStatus.toJSON(message.status);
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => Artifact.toJSON(e));
    }
    if (message.history?.length) {
      obj.history = message.history.map((e) => Message.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },
};

export const TaskStatus: MessageFns<TaskStatus> = {
  fromJSON(object: any): TaskStatus {
    return {
      state: isSet(object.state) ? taskStateFromJSON(object.state) : 0,
      update: isSet(object.message)
        ? Message.fromJSON(object.message)
        : isSet(object.update)
        ? Message.fromJSON(object.update)
        : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: TaskStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = taskStateToJSON(message.state);
    }
    if (message.update !== undefined) {
      obj.message = Message.toJSON(message.update);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },
};

export const Part: MessageFns<Part> = {
  fromJSON(object: any): Part {
    return {
      part: isSet(object.text)
        ? { $case: "text", value: globalThis.String(object.text) }
        : isSet(object.file)
        ? { $case: "file", value: FilePart.fromJSON(object.file) }
        : isSet(object.data)
        ? { $case: "data", value: DataPart.fromJSON(object.data) }
        : undefined,
    };
  },

  toJSON(message: Part): unknown {
    const obj: any = {};
    if (message.part?.$case === "text") {
      obj.text = message.part.value;
    } else if (message.part?.$case === "file") {
      obj.file = FilePart.toJSON(message.part.value);
    } else if (message.part?.$case === "data") {
      obj.data = DataPart.toJSON(message.part.value);
    }
    return obj;
  },
};

export const FilePart: MessageFns<FilePart> = {
  fromJSON(object: any): FilePart {
    return {
      file: isSet(object.file_with_uri)
        ? { $case: "fileWithUri", value: globalThis.String(object.file_with_uri) }
        : isSet(object.fileWithUri)
        ? { $case: "fileWithUri", value: globalThis.String(object.fileWithUri) }
        : isSet(object.file_with_bytes)
        ? { $case: "fileWithBytes", value: Buffer.from(bytesFromBase64(object.file_with_bytes)) }
        : isSet(object.fileWithBytes)
        ? { $case: "fileWithBytes", value: Buffer.from(bytesFromBase64(object.fileWithBytes)) }
        : undefined,
      mimeType: isSet(object.mime_type)
        ? globalThis.String(object.mime_type)
        : isSet(object.mimeType)
        ? globalThis.String(object.mimeType)
        : "",
    };
  },

  toJSON(message: FilePart): unknown {
    const obj: any = {};
    if (message.file?.$case === "fileWithUri") {
      obj.file_with_uri = message.file.value;
    } else if (message.file?.$case === "fileWithBytes") {
      obj.file_with_bytes = base64FromBytes(message.file.value);
    }
    if (message.mimeType !== "") {
      obj.mime_type = message.mimeType;
    }
    return obj;
  },
};

export const DataPart: MessageFns<DataPart> = {
  fromJSON(object: any): DataPart {
    return { data: isObject(object.data) ? object.data : undefined };
  },

  toJSON(message: DataPart): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },
};

export const Message: MessageFns<Message> = {
  fromJSON(object: any): Message {
    return {
      messageId: isSet(object.message_id)
        ? globalThis.String(object.message_id)
        : isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : "",
      contextId: isSet(object.context_id)
        ? globalThis.String(object.context_id)
        : isSet(object.contextId)
        ? globalThis.String(object.contextId)
        : "",
      taskId: isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : "",
      role: isSet(object.role) ? roleFromJSON(object.role) : 0,
      content: globalThis.Array.isArray(object?.content)
        ? object.content.map((e: any) => Part.fromJSON(e))
        : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.message_id = message.messageId;
    }
    if (message.contextId !== "") {
      obj.context_id = message.contextId;
    }
    if (message.taskId !== "") {
      obj.task_id = message.taskId;
    }
    if (message.role !== 0) {
      obj.role = roleToJSON(message.role);
    }
    if (message.content?.length) {
      obj.content = message.content.map((e) => Part.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions;
    }
    return obj;
  },
};

export const Artifact: MessageFns<Artifact> = {
  fromJSON(object: any): Artifact {
    return {
      artifactId: isSet(object.artifact_id)
        ? globalThis.String(object.artifact_id)
        : isSet(object.artifactId)
        ? globalThis.String(object.artifactId)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parts: globalThis.Array.isArray(object?.parts)
        ? object.parts.map((e: any) => Part.fromJSON(e))
        : [],
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Artifact): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifact_id = message.artifactId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => Part.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions;
    }
    return obj;
  },
};

export const TaskStatusUpdateEvent: MessageFns<TaskStatusUpdateEvent> = {
  fromJSON(object: any): TaskStatusUpdateEvent {
    return {
      taskId: isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : "",
      contextId: isSet(object.context_id)
        ? globalThis.String(object.context_id)
        : isSet(object.contextId)
        ? globalThis.String(object.contextId)
        : "",
      status: isSet(object.status) ? TaskStatus.fromJSON(object.status) : undefined,
      final: isSet(object.final) ? globalThis.Boolean(object.final) : false,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: TaskStatusUpdateEvent): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.task_id = message.taskId;
    }
    if (message.contextId !== "") {
      obj.context_id = message.contextId;
    }
    if (message.status !== undefined) {
      obj.status = TaskStatus.toJSON(message.status);
    }
    if (message.final !== false) {
      obj.final = message.final;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },
};

export const TaskArtifactUpdateEvent: MessageFns<TaskArtifactUpdateEvent> = {
  fromJSON(object: any): TaskArtifactUpdateEvent {
    return {
      taskId: isSet(object.task_id)
        ? globalThis.String(object.task_id)
        : isSet(object.taskId)
        ? globalThis.String(object.taskId)
        : "",
      contextId: isSet(object.context_id)
        ? globalThis.String(object.context_id)
        : isSet(object.contextId)
        ? globalThis.String(object.contextId)
        : "",
      artifact: isSet(object.artifact) ? Artifact.fromJSON(object.artifact) : undefined,
      append: isSet(object.append) ? globalThis.Boolean(object.append) : false,
      lastChunk: isSet(object.last_chunk)
        ? globalThis.Boolean(object.last_chunk)
        : isSet(object.lastChunk)
        ? globalThis.Boolean(object.lastChunk)
        : false,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: TaskArtifactUpdateEvent): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.task_id = message.taskId;
    }
    if (message.contextId !== "") {
      obj.context_id = message.contextId;
    }
    if (message.artifact !== undefined) {
      obj.artifact = Artifact.toJSON(message.artifact);
    }
    if (message.append !== false) {
      obj.append = message.append;
    }
    if (message.lastChunk !== false) {
      obj.last_chunk = message.lastChunk;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },
};

export const PushNotificationConfig: MessageFns<PushNotificationConfig> = {
  fromJSON(object: any): PushNotificationConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      authentication: isSet(object.authentication) ? AuthenticationInfo.fromJSON(object.authentication) : undefined,
    };
  },

  toJSON(message: PushNotificationConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.authentication !== undefined) {
      obj.authentication = AuthenticationInfo.toJSON(message.authentication);
    }
    return obj;
  },
};

export const AuthenticationInfo: MessageFns<AuthenticationInfo> = {
  fromJSON(object: any): AuthenticationInfo {
    return {
      schemes: globalThis.Array.isArray(object?.schemes) ? object.schemes.map((e: any) => globalThis.String(e)) : [],
      credentials: isSet(object.credentials) ? globalThis.String(object.credentials) : "",
    };
  },

  toJSON(message: AuthenticationInfo): unknown {
    const obj: any = {};
    if (message.schemes?.length) {
      obj.schemes = message.schemes;
    }
    if (message.credentials !== "") {
      obj.credentials = message.credentials;
    }
    return obj;
  },
};

export const AgentInterface: MessageFns<AgentInterface> = {
  fromJSON(object: any): AgentInterface {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      transport: isSet(object.transport) ? globalThis.String(object.transport) : "",
    };
  },

  toJSON(message: AgentInterface): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.transport !== "") {
      obj.transport = message.transport;
    }
    return obj;
  },
};

export const AgentCard: MessageFns<AgentCard> = {
  fromJSON(object: any): AgentCard {
    return {
      protocolVersion: isSet(object.protocol_version)
        ? globalThis.String(object.protocol_version)
        : isSet(object.protocolVersion)
        ? globalThis.String(object.protocolVersion)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      preferredTransport: isSet(object.preferred_transport)
        ? globalThis.String(object.preferred_transport)
        : isSet(object.preferredTransport)
        ? globalThis.String(object.preferredTransport)
        : "",
      additionalInterfaces: globalThis.Array.isArray(object?.additional_interfaces)
        ? object.additional_interfaces.map((e: any) => AgentInterface.fromJSON(e))
        : globalThis.Array.isArray(object?.additionalInterfaces)
        ? object.additionalInterfaces.map((e: any) => AgentInterface.fromJSON(e))
        : [],
      provider: isSet(object.provider) ? AgentProvider.fromJSON(object.provider) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      documentationUrl: isSet(object.documentation_url)
        ? globalThis.String(object.documentation_url)
        : isSet(object.documentationUrl)
        ? globalThis.String(object.documentationUrl)
        : "",
      capabilities: isSet(object.capabilities) ? AgentCapabilities.fromJSON(object.capabilities) : undefined,
      securitySchemes: isObject(object.security_schemes)
        ? (globalThis.Object.entries(object.security_schemes) as [string, any][]).reduce(
          (acc: { [key: string]: SecurityScheme }, [key, value]: [string, any]) => {
            acc[key] = SecurityScheme.fromJSON(value);
            return acc;
          },
          {},
        )
        : isObject(object.securitySchemes)
        ? (globalThis.Object.entries(object.securitySchemes) as [string, any][]).reduce(
          (acc: { [key: string]: SecurityScheme }, [key, value]: [string, any]) => {
            acc[key] = SecurityScheme.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      security: globalThis.Array.isArray(object?.security)
        ? object.security.map((e: any) => Security.fromJSON(e))
        : [],
      defaultInputModes: globalThis.Array.isArray(object?.default_input_modes)
        ? object.default_input_modes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.defaultInputModes)
        ? object.defaultInputModes.map((e: any) => globalThis.String(e))
        : [],
      defaultOutputModes: globalThis.Array.isArray(object?.default_output_modes)
        ? object.default_output_modes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.defaultOutputModes)
        ? object.defaultOutputModes.map((e: any) => globalThis.String(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills)
        ? object.skills.map((e: any) => AgentSkill.fromJSON(e))
        : [],
      supportsAuthenticatedExtendedCard: isSet(object.supports_authenticated_extended_card)
        ? globalThis.Boolean(object.supports_authenticated_extended_card)
        : isSet(object.supportsAuthenticatedExtendedCard)
        ? globalThis.Boolean(object.supportsAuthenticatedExtendedCard)
        : false,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => AgentCardSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentCard): unknown {
    const obj: any = {};
    if (message.protocolVersion !== "") {
      obj.protocol_version = message.protocolVersion;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.preferredTransport !== "") {
      obj.preferred_transport = message.preferredTransport;
    }
    if (message.additionalInterfaces?.length) {
      obj.additional_interfaces = message.additionalInterfaces.map((e) => AgentInterface.toJSON(e));
    }
    if (message.provider !== undefined) {
      obj.provider = AgentProvider.toJSON(message.provider);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.documentationUrl !== "") {
      obj.documentation_url = message.documentationUrl;
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = AgentCapabilities.toJSON(message.capabilities);
    }
    if (message.securitySchemes) {
      const entries = globalThis.Object.entries(message.securitySchemes) as [string, SecurityScheme][];
      if (entries.length > 0) {
        obj.security_schemes = {};
        entries.forEach(([k, v]) => {
          obj.security_schemes[k] = SecurityScheme.toJSON(v);
        });
      }
    }
    if (message.security?.length) {
      obj.security = message.security.map((e) => Security.toJSON(e));
    }
    if (message.defaultInputModes?.length) {
      obj.default_input_modes = message.defaultInputModes;
    }
    if (message.defaultOutputModes?.length) {
      obj.default_output_modes = message.defaultOutputModes;
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => AgentSkill.toJSON(e));
    }
    if (message.supportsAuthenticatedExtendedCard !== false) {
      obj.supports_authenticated_extended_card = message.supportsAuthenticatedExtendedCard;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => AgentCardSignature.toJSON(e));
    }
    return obj;
  },
};

export const AgentCard_SecuritySchemesEntry: MessageFns<AgentCard_SecuritySchemesEntry> = {
  fromJSON(object: any): AgentCard_SecuritySchemesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecurityScheme.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AgentCard_SecuritySchemesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecurityScheme.toJSON(message.value);
    }
    return obj;
  },
};

export const AgentProvider: MessageFns<AgentProvider> = {
  fromJSON(object: any): AgentProvider {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
    };
  },

  toJSON(message: AgentProvider): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    return obj;
  },
};

export const AgentCapabilities: MessageFns<AgentCapabilities> = {
  fromJSON(object: any): AgentCapabilities {
    return {
      streaming: isSet(object.streaming) ? globalThis.Boolean(object.streaming) : false,
      pushNotifications: isSet(object.push_notifications)
        ? globalThis.Boolean(object.push_notifications)
        : isSet(object.pushNotifications)
        ? globalThis.Boolean(object.pushNotifications)
        : false,
      extensions: globalThis.Array.isArray(object?.extensions)
        ? object.extensions.map((e: any) => AgentExtension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentCapabilities): unknown {
    const obj: any = {};
    if (message.streaming !== false) {
      obj.streaming = message.streaming;
    }
    if (message.pushNotifications !== false) {
      obj.push_notifications = message.pushNotifications;
    }
    if (message.extensions?.length) {
      obj.extensions = message.extensions.map((e) => AgentExtension.toJSON(e));
    }
    return obj;
  },
};

export const AgentExtension: MessageFns<AgentExtension> = {
  fromJSON(object: any): AgentExtension {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      params: isObject(object.params) ? object.params : undefined,
    };
  },

  toJSON(message: AgentExtension): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },
};

export const AgentSkill: MessageFns<AgentSkill> = {
  fromJSON(object: any): AgentSkill {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      examples: globalThis.Array.isArray(object?.examples) ? object.examples.map((e: any) => globalThis.String(e)) : [],
      inputModes: globalThis.Array.isArray(object?.input_modes)
        ? object.input_modes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.inputModes)
        ? object.inputModes.map((e: any) => globalThis.String(e))
        : [],
      outputModes: globalThis.Array.isArray(object?.output_modes)
        ? object.output_modes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.outputModes)
        ? object.outputModes.map((e: any) => globalThis.String(e))
        : [],
      security: globalThis.Array.isArray(object?.security) ? object.security.map((e: any) => Security.fromJSON(e)) : [],
    };
  },

  toJSON(message: AgentSkill): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.examples?.length) {
      obj.examples = message.examples;
    }
    if (message.inputModes?.length) {
      obj.input_modes = message.inputModes;
    }
    if (message.outputModes?.length) {
      obj.output_modes = message.outputModes;
    }
    if (message.security?.length) {
      obj.security = message.security.map((e) => Security.toJSON(e));
    }
    return obj;
  },
};

export const AgentCardSignature: MessageFns<AgentCardSignature> = {
  fromJSON(object: any): AgentCardSignature {
    return {
      protected: isSet(object.protected) ? globalThis.String(object.protected) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      header: isObject(object.header) ? object.header : undefined,
    };
  },

  toJSON(message: AgentCardSignature): unknown {
    const obj: any = {};
    if (message.protected !== "") {
      obj.protected = message.protected;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.header !== undefined) {
      obj.header = message.header;
    }
    return obj;
  },
};

export const TaskPushNotificationConfig: MessageFns<TaskPushNotificationConfig> = {
  fromJSON(object: any): TaskPushNotificationConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pushNotificationConfig: isSet(object.push_notification_config)
        ? PushNotificationConfig.fromJSON(object.push_notification_config)
        : isSet(object.pushNotificationConfig)
        ? PushNotificationConfig.fromJSON(object.pushNotificationConfig)
        : undefined,
    };
  },

  toJSON(message: TaskPushNotificationConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pushNotificationConfig !== undefined) {
      obj.push_notification_config = PushNotificationConfig.toJSON(message.pushNotificationConfig);
    }
    return obj;
  },
};

export const StringList: MessageFns<StringList> = {
  fromJSON(object: any): StringList {
    return { list: globalThis.Array.isArray(object?.list) ? object.list.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: StringList): unknown {
    const obj: any = {};
    if (message.list?.length) {
      obj.list = message.list;
    }
    return obj;
  },
};

export const Security: MessageFns<Security> = {
  fromJSON(object: any): Security {
    return {
      schemes: isObject(object.schemes)
        ? (globalThis.Object.entries(object.schemes) as [string, any][]).reduce(
          (acc: { [key: string]: StringList }, [key, value]: [string, any]) => {
            acc[key] = StringList.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: Security): unknown {
    const obj: any = {};
    if (message.schemes) {
      const entries = globalThis.Object.entries(message.schemes) as [string, StringList][];
      if (entries.length > 0) {
        obj.schemes = {};
        entries.forEach(([k, v]) => {
          obj.schemes[k] = StringList.toJSON(v);
        });
      }
    }
    return obj;
  },
};

export const Security_SchemesEntry: MessageFns<Security_SchemesEntry> = {
  fromJSON(object: any): Security_SchemesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? StringList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Security_SchemesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = StringList.toJSON(message.value);
    }
    return obj;
  },
};

export const SecurityScheme: MessageFns<SecurityScheme> = {
  fromJSON(object: any): SecurityScheme {
    return {
      scheme: isSet(object.api_key_security_scheme)
        ? { $case: "apiKeySecurityScheme", value: APIKeySecurityScheme.fromJSON(object.api_key_security_scheme) }
        : isSet(object.apiKeySecurityScheme)
        ? { $case: "apiKeySecurityScheme", value: APIKeySecurityScheme.fromJSON(object.apiKeySecurityScheme) }
        : isSet(object.http_auth_security_scheme)
        ? { $case: "httpAuthSecurityScheme", value: HTTPAuthSecurityScheme.fromJSON(object.http_auth_security_scheme) }
        : isSet(object.httpAuthSecurityScheme)
        ? { $case: "httpAuthSecurityScheme", value: HTTPAuthSecurityScheme.fromJSON(object.httpAuthSecurityScheme) }
        : isSet(object.oauth2_security_scheme)
        ? { $case: "oauth2SecurityScheme", value: OAuth2SecurityScheme.fromJSON(object.oauth2_security_scheme) }
        : isSet(object.oauth2SecurityScheme)
        ? { $case: "oauth2SecurityScheme", value: OAuth2SecurityScheme.fromJSON(object.oauth2SecurityScheme) }
        : isSet(object.open_id_connect_security_scheme)
        ? {
          $case: "openIdConnectSecurityScheme",
          value: OpenIdConnectSecurityScheme.fromJSON(object.open_id_connect_security_scheme),
        }
        : isSet(object.openIdConnectSecurityScheme)
        ? {
          $case: "openIdConnectSecurityScheme",
          value: OpenIdConnectSecurityScheme.fromJSON(object.openIdConnectSecurityScheme),
        }
        : isSet(object.mtls_security_scheme)
        ? { $case: "mtlsSecurityScheme", value: MutualTlsSecurityScheme.fromJSON(object.mtls_security_scheme) }
        : isSet(object.mtlsSecurityScheme)
        ? { $case: "mtlsSecurityScheme", value: MutualTlsSecurityScheme.fromJSON(object.mtlsSecurityScheme) }
        : undefined,
    };
  },

  toJSON(message: SecurityScheme): unknown {
    const obj: any = {};
    if (message.scheme?.$case === "apiKeySecurityScheme") {
      obj.api_key_security_scheme = APIKeySecurityScheme.toJSON(message.scheme.value);
    } else if (message.scheme?.$case === "httpAuthSecurityScheme") {
      obj.http_auth_security_scheme = HTTPAuthSecurityScheme.toJSON(message.scheme.value);
    } else if (message.scheme?.$case === "oauth2SecurityScheme") {
      obj.oauth2_security_scheme = OAuth2SecurityScheme.toJSON(message.scheme.value);
    } else if (message.scheme?.$case === "openIdConnectSecurityScheme") {
      obj.open_id_connect_security_scheme = OpenIdConnectSecurityScheme.toJSON(message.scheme.value);
    } else if (message.scheme?.$case === "mtlsSecurityScheme") {
      obj.mtls_security_scheme = MutualTlsSecurityScheme.toJSON(message.scheme.value);
    }
    return obj;
  },
};

export const APIKeySecurityScheme: MessageFns<APIKeySecurityScheme> = {
  fromJSON(object: any): APIKeySecurityScheme {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: APIKeySecurityScheme): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

export const HTTPAuthSecurityScheme: MessageFns<HTTPAuthSecurityScheme> = {
  fromJSON(object: any): HTTPAuthSecurityScheme {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      bearerFormat: isSet(object.bearer_format)
        ? globalThis.String(object.bearer_format)
        : isSet(object.bearerFormat)
        ? globalThis.String(object.bearerFormat)
        : "",
    };
  },

  toJSON(message: HTTPAuthSecurityScheme): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.bearerFormat !== "") {
      obj.bearer_format = message.bearerFormat;
    }
    return obj;
  },
};

export const OAuth2SecurityScheme: MessageFns<OAuth2SecurityScheme> = {
  fromJSON(object: any): OAuth2SecurityScheme {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      flows: isSet(object.flows) ? OAuthFlows.fromJSON(object.flows) : undefined,
      oauth2MetadataUrl: isSet(object.oauth2_metadata_url)
        ? globalThis.String(object.oauth2_metadata_url)
        : isSet(object.oauth2MetadataUrl)
        ? globalThis.String(object.oauth2MetadataUrl)
        : "",
    };
  },

  toJSON(message: OAuth2SecurityScheme): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.flows !== undefined) {
      obj.flows = OAuthFlows.toJSON(message.flows);
    }
    if (message.oauth2MetadataUrl !== "") {
      obj.oauth2_metadata_url = message.oauth2MetadataUrl;
    }
    return obj;
  },
};

export const OpenIdConnectSecurityScheme: MessageFns<OpenIdConnectSecurityScheme> = {
  fromJSON(object: any): OpenIdConnectSecurityScheme {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      openIdConnectUrl: isSet(object.open_id_connect_url)
        ? globalThis.String(object.open_id_connect_url)
        : isSet(object.openIdConnectUrl)
        ? globalThis.String(object.openIdConnectUrl)
        : "",
    };
  },

  toJSON(message: OpenIdConnectSecurityScheme): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.openIdConnectUrl !== "") {
      obj.open_id_connect_url = message.openIdConnectUrl;
    }
    return obj;
  },
};

export const MutualTlsSecurityScheme: MessageFns<MutualTlsSecurityScheme> = {
  fromJSON(object: any): MutualTlsSecurityScheme {
    return { description: isSet(object.description) ? globalThis.String(object.description) : "" };
  },

  toJSON(message: MutualTlsSecurityScheme): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },
};

export const OAuthFlows: MessageFns<OAuthFlows> = {
  fromJSON(object: any): OAuthFlows {
    return {
      flow: isSet(object.authorization_code)
        ? { $case: "authorizationCode", value: AuthorizationCodeOAuthFlow.fromJSON(object.authorization_code) }
        : isSet(object.authorizationCode)
        ? { $case: "authorizationCode", value: AuthorizationCodeOAuthFlow.fromJSON(object.authorizationCode) }
        : isSet(object.client_credentials)
        ? { $case: "clientCredentials", value: ClientCredentialsOAuthFlow.fromJSON(object.client_credentials) }
        : isSet(object.clientCredentials)
        ? { $case: "clientCredentials", value: ClientCredentialsOAuthFlow.fromJSON(object.clientCredentials) }
        : isSet(object.implicit)
        ? { $case: "implicit", value: ImplicitOAuthFlow.fromJSON(object.implicit) }
        : isSet(object.password)
        ? { $case: "password", value: PasswordOAuthFlow.fromJSON(object.password) }
        : undefined,
    };
  },

  toJSON(message: OAuthFlows): unknown {
    const obj: any = {};
    if (message.flow?.$case === "authorizationCode") {
      obj.authorization_code = AuthorizationCodeOAuthFlow.toJSON(message.flow.value);
    } else if (message.flow?.$case === "clientCredentials") {
      obj.client_credentials = ClientCredentialsOAuthFlow.toJSON(message.flow.value);
    } else if (message.flow?.$case === "implicit") {
      obj.implicit = ImplicitOAuthFlow.toJSON(message.flow.value);
    } else if (message.flow?.$case === "password") {
      obj.password = PasswordOAuthFlow.toJSON(message.flow.value);
    }
    return obj;
  },
};

export const AuthorizationCodeOAuthFlow: MessageFns<AuthorizationCodeOAuthFlow> = {
  fromJSON(object: any): AuthorizationCodeOAuthFlow {
    return {
      authorizationUrl: isSet(object.authorization_url)
        ? globalThis.String(object.authorization_url)
        : isSet(object.authorizationUrl)
        ? globalThis.String(object.authorizationUrl)
        : "",
      tokenUrl: isSet(object.token_url)
        ? globalThis.String(object.token_url)
        : isSet(object.tokenUrl)
        ? globalThis.String(object.tokenUrl)
        : "",
      refreshUrl: isSet(object.refresh_url)
        ? globalThis.String(object.refresh_url)
        : isSet(object.refreshUrl)
        ? globalThis.String(object.refreshUrl)
        : "",
      scopes: isObject(object.scopes)
        ? (globalThis.Object.entries(object.scopes) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: AuthorizationCodeOAuthFlow): unknown {
    const obj: any = {};
    if (message.authorizationUrl !== "") {
      obj.authorization_url = message.authorizationUrl;
    }
    if (message.tokenUrl !== "") {
      obj.token_url = message.tokenUrl;
    }
    if (message.refreshUrl !== "") {
      obj.refresh_url = message.refreshUrl;
    }
    if (message.scopes) {
      const entries = globalThis.Object.entries(message.scopes) as [string, string][];
      if (entries.length > 0) {
        obj.scopes = {};
        entries.forEach(([k, v]) => {
          obj.scopes[k] = v;
        });
      }
    }
    return obj;
  },
};

export const AuthorizationCodeOAuthFlow_ScopesEntry: MessageFns<AuthorizationCodeOAuthFlow_ScopesEntry> = {
  fromJSON(object: any): AuthorizationCodeOAuthFlow_ScopesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuthorizationCodeOAuthFlow_ScopesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

export const ClientCredentialsOAuthFlow: MessageFns<ClientCredentialsOAuthFlow> = {
  fromJSON(object: any): ClientCredentialsOAuthFlow {
    return {
      tokenUrl: isSet(object.token_url)
        ? globalThis.String(object.token_url)
        : isSet(object.tokenUrl)
        ? globalThis.String(object.tokenUrl)
        : "",
      refreshUrl: isSet(object.refresh_url)
        ? globalThis.String(object.refresh_url)
        : isSet(object.refreshUrl)
        ? globalThis.String(object.refreshUrl)
        : "",
      scopes: isObject(object.scopes)
        ? (globalThis.Object.entries(object.scopes) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ClientCredentialsOAuthFlow): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.token_url = message.tokenUrl;
    }
    if (message.refreshUrl !== "") {
      obj.refresh_url = message.refreshUrl;
    }
    if (message.scopes) {
      const entries = globalThis.Object.entries(message.scopes) as [string, string][];
      if (entries.length > 0) {
        obj.scopes = {};
        entries.forEach(([k, v]) => {
          obj.scopes[k] = v;
        });
      }
    }
    return obj;
  },
};

export const ClientCredentialsOAuthFlow_ScopesEntry: MessageFns<ClientCredentialsOAuthFlow_ScopesEntry> = {
  fromJSON(object: any): ClientCredentialsOAuthFlow_ScopesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ClientCredentialsOAuthFlow_ScopesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

export const ImplicitOAuthFlow: MessageFns<ImplicitOAuthFlow> = {
  fromJSON(object: any): ImplicitOAuthFlow {
    return {
      authorizationUrl: isSet(object.authorization_url)
        ? globalThis.String(object.authorization_url)
        : isSet(object.authorizationUrl)
        ? globalThis.String(object.authorizationUrl)
        : "",
      refreshUrl: isSet(object.refresh_url)
        ? globalThis.String(object.refresh_url)
        : isSet(object.refreshUrl)
        ? globalThis.String(object.refreshUrl)
        : "",
      scopes: isObject(object.scopes)
        ? (globalThis.Object.entries(object.scopes) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: ImplicitOAuthFlow): unknown {
    const obj: any = {};
    if (message.authorizationUrl !== "") {
      obj.authorization_url = message.authorizationUrl;
    }
    if (message.refreshUrl !== "") {
      obj.refresh_url = message.refreshUrl;
    }
    if (message.scopes) {
      const entries = globalThis.Object.entries(message.scopes) as [string, string][];
      if (entries.length > 0) {
        obj.scopes = {};
        entries.forEach(([k, v]) => {
          obj.scopes[k] = v;
        });
      }
    }
    return obj;
  },
};

export const ImplicitOAuthFlow_ScopesEntry: MessageFns<ImplicitOAuthFlow_ScopesEntry> = {
  fromJSON(object: any): ImplicitOAuthFlow_ScopesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ImplicitOAuthFlow_ScopesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

export const PasswordOAuthFlow: MessageFns<PasswordOAuthFlow> = {
  fromJSON(object: any): PasswordOAuthFlow {
    return {
      tokenUrl: isSet(object.token_url)
        ? globalThis.String(object.token_url)
        : isSet(object.tokenUrl)
        ? globalThis.String(object.tokenUrl)
        : "",
      refreshUrl: isSet(object.refresh_url)
        ? globalThis.String(object.refresh_url)
        : isSet(object.refreshUrl)
        ? globalThis.String(object.refreshUrl)
        : "",
      scopes: isObject(object.scopes)
        ? (globalThis.Object.entries(object.scopes) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: PasswordOAuthFlow): unknown {
    const obj: any = {};
    if (message.tokenUrl !== "") {
      obj.token_url = message.tokenUrl;
    }
    if (message.refreshUrl !== "") {
      obj.refresh_url = message.refreshUrl;
    }
    if (message.scopes) {
      const entries = globalThis.Object.entries(message.scopes) as [string, string][];
      if (entries.length > 0) {
        obj.scopes = {};
        entries.forEach(([k, v]) => {
          obj.scopes[k] = v;
        });
      }
    }
    return obj;
  },
};

export const PasswordOAuthFlow_ScopesEntry: MessageFns<PasswordOAuthFlow_ScopesEntry> = {
  fromJSON(object: any): PasswordOAuthFlow_ScopesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PasswordOAuthFlow_ScopesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  fromJSON(object: any): SendMessageRequest {
    return {
      request: isSet(object.message)
        ? Message.fromJSON(object.message)
        : isSet(object.request)
        ? Message.fromJSON(object.request)
        : undefined,
      configuration: isSet(object.configuration) ? SendMessageConfiguration.fromJSON(object.configuration) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.message = Message.toJSON(message.request);
    }
    if (message.configuration !== undefined) {
      obj.configuration = SendMessageConfiguration.toJSON(message.configuration);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },
};

export const GetTaskRequest: MessageFns<GetTaskRequest> = {
  fromJSON(object: any): GetTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      historyLength: isSet(object.history_length)
        ? globalThis.Number(object.history_length)
        : isSet(object.historyLength)
        ? globalThis.Number(object.historyLength)
        : 0,
    };
  },

  toJSON(message: GetTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.historyLength !== 0) {
      obj.history_length = Math.round(message.historyLength);
    }
    return obj;
  },
};

export const CancelTaskRequest: MessageFns<CancelTaskRequest> = {
  fromJSON(object: any): CancelTaskRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

export const GetTaskPushNotificationConfigRequest: MessageFns<GetTaskPushNotificationConfigRequest> = {
  fromJSON(object: any): GetTaskPushNotificationConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTaskPushNotificationConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

export const DeleteTaskPushNotificationConfigRequest: MessageFns<DeleteTaskPushNotificationConfigRequest> = {
  fromJSON(object: any): DeleteTaskPushNotificationConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTaskPushNotificationConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

export const CreateTaskPushNotificationConfigRequest: MessageFns<CreateTaskPushNotificationConfigRequest> = {
  fromJSON(object: any): CreateTaskPushNotificationConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      configId: isSet(object.config_id)
        ? globalThis.String(object.config_id)
        : isSet(object.configId)
        ? globalThis.String(object.configId)
        : "",
      config: isSet(object.config) ? TaskPushNotificationConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: CreateTaskPushNotificationConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.configId !== "") {
      obj.config_id = message.configId;
    }
    if (message.config !== undefined) {
      obj.config = TaskPushNotificationConfig.toJSON(message.config);
    }
    return obj;
  },
};

export const TaskSubscriptionRequest: MessageFns<TaskSubscriptionRequest> = {
  fromJSON(object: any): TaskSubscriptionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: TaskSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
};

export const ListTaskPushNotificationConfigRequest: MessageFns<ListTaskPushNotificationConfigRequest> = {
  fromJSON(object: any): ListTaskPushNotificationConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : 0,
      pageToken: isSet(object.page_token)
        ? globalThis.String(object.page_token)
        : isSet(object.pageToken)
        ? globalThis.String(object.pageToken)
        : "",
    };
  },

  toJSON(message: ListTaskPushNotificationConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.page_size = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.page_token = message.pageToken;
    }
    return obj;
  },
};

export const GetAgentCardRequest: MessageFns<GetAgentCardRequest> = {
  fromJSON(_: any): GetAgentCardRequest {
    return {};
  },

  toJSON(_: GetAgentCardRequest): unknown {
    const obj: any = {};
    return obj;
  },
};

export const SendMessageResponse: MessageFns<SendMessageResponse> = {
  fromJSON(object: any): SendMessageResponse {
    return {
      payload: isSet(object.task)
        ? { $case: "task", value: Task.fromJSON(object.task) }
        : isSet(object.message)
        ? { $case: "msg", value: Message.fromJSON(object.message) }
        : isSet(object.msg)
        ? { $case: "msg", value: Message.fromJSON(object.msg) }
        : undefined,
    };
  },

  toJSON(message: SendMessageResponse): unknown {
    const obj: any = {};
    if (message.payload?.$case === "task") {
      obj.task = Task.toJSON(message.payload.value);
    } else if (message.payload?.$case === "msg") {
      obj.message = Message.toJSON(message.payload.value);
    }
    return obj;
  },
};

export const StreamResponse: MessageFns<StreamResponse> = {
  fromJSON(object: any): StreamResponse {
    return {
      payload: isSet(object.task)
        ? { $case: "task", value: Task.fromJSON(object.task) }
        : isSet(object.message)
        ? { $case: "msg", value: Message.fromJSON(object.message) }
        : isSet(object.msg)
        ? { $case: "msg", value: Message.fromJSON(object.msg) }
        : isSet(object.status_update)
        ? { $case: "statusUpdate", value: TaskStatusUpdateEvent.fromJSON(object.status_update) }
        : isSet(object.statusUpdate)
        ? { $case: "statusUpdate", value: TaskStatusUpdateEvent.fromJSON(object.statusUpdate) }
        : isSet(object.artifact_update)
        ? { $case: "artifactUpdate", value: TaskArtifactUpdateEvent.fromJSON(object.artifact_update) }
        : isSet(object.artifactUpdate)
        ? { $case: "artifactUpdate", value: TaskArtifactUpdateEvent.fromJSON(object.artifactUpdate) }
        : undefined,
    };
  },

  toJSON(message: StreamResponse): unknown {
    const obj: any = {};
    if (message.payload?.$case === "task") {
      obj.task = Task.toJSON(message.payload.value);
    } else if (message.payload?.$case === "msg") {
      obj.message = Message.toJSON(message.payload.value);
    } else if (message.payload?.$case === "statusUpdate") {
      obj.status_update = TaskStatusUpdateEvent.toJSON(message.payload.value);
    } else if (message.payload?.$case === "artifactUpdate") {
      obj.artifact_update = TaskArtifactUpdateEvent.toJSON(message.payload.value);
    }
    return obj;
  },
};

export const ListTaskPushNotificationConfigResponse: MessageFns<ListTaskPushNotificationConfigResponse> = {
  fromJSON(object: any): ListTaskPushNotificationConfigResponse {
    return {
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => TaskPushNotificationConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.next_page_token)
        ? globalThis.String(object.next_page_token)
        : isSet(object.nextPageToken)
        ? globalThis.String(object.nextPageToken)
        : "",
    };
  },

  toJSON(message: ListTaskPushNotificationConfigResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => TaskPushNotificationConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.next_page_token = message.nextPageToken;
    }
    return obj;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
